{
  long available=buf.readableBytes();
  if (available < 2) {
    return null;
  }
  List<Object> ret=new ArrayList<Object>();
  timer.start();
  ;
  try {
    int decodeNum=0;
    while (available >= 2 && decodeNum < BATCH_SIZE) {
      buf.markReaderIndex();
      short code=buf.readShort();
      available-=2;
      ControlMessage ctrl_msg=ControlMessage.mkMessage(code);
      if (ctrl_msg != null) {
        if (ctrl_msg == ControlMessage.EOB_MESSAGE) {
          continue;
        }
 else {
          LOG.warn("Occur invalid control message {}",ctrl_msg);
          break;
        }
      }
      short task=code;
      if (available < 4) {
        buf.resetReaderIndex();
        break;
      }
      int length=buf.readInt();
      available-=4;
      if (length <= 0) {
        LOG.info("Receive one empty TaskMessage");
        break;
      }
      if (available < length) {
        buf.resetReaderIndex();
        break;
      }
      available-=length;
      ChannelBuffer payload=buf.readBytes(length);
      ret.add(new TaskMessage(task,payload.array()));
      decodeNum++;
    }
  }
  finally {
    timer.stop();
    histogram.update(ret.size());
  }
  if (ret.size() == 0) {
    return null;
  }
 else {
    return ret;
  }
}
