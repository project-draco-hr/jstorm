{
  long begin=System.currentTimeMillis();
  boolean changeThreadhold=false;
  IntervalCheck oneSecond=new IntervalCheck();
  IntervalCheck timeoutIntervalCheck=new IntervalCheck();
  timeoutIntervalCheck.setInterval(timeoutSecond);
  while (isChannelReady() == null) {
    long now=System.currentTimeMillis();
    long delt=now - begin;
    if (oneSecond.check() == true) {
      LOG.warn("Target server  {} is unavailable, pending {}, bufferSize {}, block sending {}ms",name,pendings.get(),cachedSize,delt);
    }
    if (timeoutIntervalCheck.check() == true) {
      if (messageBatchRef.get() != null) {
        LOG.warn("Target server  {} is unavailable, wait too much time, throw timeout message",name);
        messageBatchRef.set(null);
      }
      setChannel(null);
      LOG.warn("Reset channel as null");
    }
    reconnect();
    JStormUtils.sleepMs(sleepMs);
    if (delt > 2 * timeoutSecond * 1000L && changeThreadhold == false) {
      if (channelRef.get() != null && BATCH_THREASHOLD_WARN >= 2 * messageBatchSize) {
        BATCH_THREASHOLD_WARN=BATCH_THREASHOLD_WARN / 2;
        LOG.info("Reduce BATCH_THREASHOLD_WARN to {}",BATCH_THREASHOLD_WARN);
        changeThreadhold=true;
      }
    }
  }
}
