{
  this.storm_conf=storm_conf;
  this.port=port;
  useDisruptor=ConfigExtension.isNettyEnableDisruptor(storm_conf);
  blockQ=new LinkedBlockingQueue<TaskMessage>();
  int queue_size=Utils.getInt(storm_conf.get(Config.TOPOLOGY_TRANSFER_BUFFER_SIZE));
  WaitStrategy waitStrategy=(WaitStrategy)Utils.newInstance((String)storm_conf.get(Config.TOPOLOGY_DISRUPTOR_WAIT_STRATEGY));
  disruptorQ=new DisruptorQueue(new SingleThreadedClaimStrategy(queue_size),waitStrategy);
  int buffer_size=Utils.getInt(storm_conf.get(Config.STORM_MESSAGING_NETTY_BUFFER_SIZE));
  int maxWorkers=Utils.getInt(storm_conf.get(Config.STORM_MESSAGING_NETTY_SERVER_WORKER_THREADS));
  if (maxWorkers > 0) {
    factory=new NioServerSocketChannelFactory(Executors.newCachedThreadPool(),Executors.newCachedThreadPool(),maxWorkers);
  }
 else {
    factory=new NioServerSocketChannelFactory(Executors.newCachedThreadPool(),Executors.newCachedThreadPool());
  }
  bootstrap=new ServerBootstrap(factory);
  bootstrap.setOption("child.tcpNoDelay",true);
  bootstrap.setOption("child.receiveBufferSize",buffer_size);
  bootstrap.setOption("child.keepAlive",true);
  bootstrap.setPipelineFactory(new StormServerPipelineFactory(this));
  Channel channel=bootstrap.bind(new InetSocketAddress(port));
  allChannels.add(channel);
  LOG.info("Successfull bind {}, use disruptor:{}",port,useDisruptor);
}
