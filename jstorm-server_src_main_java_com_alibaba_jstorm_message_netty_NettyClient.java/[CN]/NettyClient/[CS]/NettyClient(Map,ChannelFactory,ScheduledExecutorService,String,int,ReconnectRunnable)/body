{
  this.factory=factory;
  this.scheduler=scheduler;
  this.reconnector=reconnector;
  retries=new AtomicInteger(0);
  channelRef=new AtomicReference<Channel>(null);
  being_closed=new AtomicBoolean(false);
  pendings=new AtomicLong(0);
  buffer_size=Utils.getInt(storm_conf.get(Config.STORM_MESSAGING_NETTY_BUFFER_SIZE));
  max_retries=Math.min(30,Utils.getInt(storm_conf.get(Config.STORM_MESSAGING_NETTY_MAX_RETRIES)));
  base_sleep_ms=Utils.getInt(storm_conf.get(Config.STORM_MESSAGING_NETTY_MIN_SLEEP_MS));
  max_sleep_ms=Utils.getInt(storm_conf.get(Config.STORM_MESSAGING_NETTY_MAX_SLEEP_MS));
  timeoutSecond=JStormUtils.parseInt(storm_conf.get(Config.TOPOLOGY_MESSAGE_TIMEOUT_SECS),30);
  MAX_SEND_PENDING=(int)ConfigExtension.getNettyMaxSendPending(storm_conf);
  this.messageBatchSize=Utils.getInt(storm_conf.get(Config.STORM_NETTY_MESSAGE_BATCH_SIZE),262144);
  messageBatchRef=new AtomicReference<MessageBatch>();
  remote_addr=new InetSocketAddress(host,port);
  name=remote_addr.toString();
  address=JStormServerUtils.getName(host,port);
  sendTimer=Metrics.registerTimer(address,MetricDef.NETTY_CLI_SEND_TIME,null,Metrics.MetricType.WORKER);
  histogram=Metrics.registerHistograms(address,MetricDef.NETTY_CLI_BATCH_SIZE,null,Metrics.MetricType.WORKER);
  Metrics.register(address,MetricDef.NETTY_CLI_SEND_PENDING,new Gauge<Long>(){
    @Override public Long getValue(){
      return pendings.get();
    }
  }
,null,Metrics.MetricType.WORKER);
  closingChannel=new HashSet<Channel>();
}
