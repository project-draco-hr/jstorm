{
  List<WorkerSlot> availableSlots=cluster.getAvailableSlots();
  Set<ExecutorDetails> allExecutors=(Set<ExecutorDetails>)topology.getExecutors();
  Map<WorkerSlot,List<ExecutorDetails>> aliveAssigned=getAliveAssignedWorkerSlotExecutors(cluster,topology.getId());
  int totalSlotsToUse=Math.min(topology.getNumWorkers(),availableSlots.size() + aliveAssigned.size());
  Collections.sort(availableSlots,new Comparator<WorkerSlot>(){
    @Override public int compare(    WorkerSlot o1,    WorkerSlot o2){
      if (o1.getPort() > o2.getPort())       return 1;
 else       if (o1.getPort() == o2.getPort())       return 0;
 else       return -1;
    }
  }
);
  List<WorkerSlot> reassignSlots=availableSlots.subList(0,totalSlotsToUse - aliveAssigned.size());
  Set<ExecutorDetails> aliveExecutors=new HashSet<ExecutorDetails>();
  for (  List<ExecutorDetails> cache : aliveAssigned.values()) {
    aliveExecutors.addAll(cache);
  }
  for (  ExecutorDetails details : allExecutors) {
    if (aliveExecutors.contains(details))     allExecutors.remove(details);
  }
  Map<ExecutorDetails,WorkerSlot> result=new HashMap<ExecutorDetails,WorkerSlot>();
  int num=0;
  int length=reassignSlots.size();
  for (  ExecutorDetails details : allExecutors) {
    int key=num % length;
    result.put(details,reassignSlots.get(key));
    num++;
  }
  if (result.size() != 0) {
    LOG.info("Available slot:");
    for (    WorkerSlot slot : availableSlots)     LOG.info(slot.toString());
  }
  return result;
}
