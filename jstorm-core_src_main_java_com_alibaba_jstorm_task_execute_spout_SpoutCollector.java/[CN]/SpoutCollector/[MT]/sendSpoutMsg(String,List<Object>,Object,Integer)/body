{
  final long startTime=System.nanoTime();
  try {
    List<Integer> out_tasks;
    if (out_task_id != null) {
      out_tasks=sendTargets.get(out_task_id,out_stream_id,values);
    }
 else {
      out_tasks=sendTargets.get(out_stream_id,values);
    }
    if (out_tasks.size() == 0) {
      return out_tasks;
    }
    List<Long> ackSeq=new ArrayList<Long>();
    Boolean needAck=(message_id != null) && (ackerNum > 0);
    Long root_id=MessageId.generateId(random);
    if (needAck) {
      while (pending.containsKey(root_id)) {
        root_id=MessageId.generateId(random);
      }
    }
    for (    Integer t : out_tasks) {
      MessageId msgid;
      if (needAck) {
        Long as=MessageId.generateId(random);
        msgid=MessageId.makeRootId(root_id,as);
        ackSeq.add(as);
      }
 else {
        msgid=MessageId.makeUnanchored();
      }
      TupleImplExt tp=new TupleImplExt(topology_context,values,task_id,out_stream_id,msgid);
      tp.setTargetTaskId(t);
      transfer_fn.transfer(tp);
    }
    if (needAck) {
      TupleInfo info=new TupleInfo();
      info.setStream(out_stream_id);
      info.setValues(values);
      info.setMessageId(message_id);
      info.setTimestamp(System.nanoTime());
      pending.putHead(root_id,info);
      List<Object> ackerTuple=JStormUtils.mk_list((Object)root_id,JStormUtils.bit_xor_vals(ackSeq),task_id);
      UnanchoredSend.send(topology_context,sendTargets,transfer_fn,Acker.ACKER_INIT_STREAM_ID,ackerTuple);
    }
 else     if (message_id != null) {
      TupleInfo info=new TupleInfo();
      info.setStream(out_stream_id);
      info.setValues(values);
      info.setMessageId(message_id);
      info.setTimestamp(0);
      AckSpoutMsg ack=new AckSpoutMsg(spout,null,info,task_stats,isDebug);
      ack.run();
    }
    return out_tasks;
  }
  finally {
    long endTime=System.nanoTime();
    emitTotalTimer.update((endTime - startTime) / TimeUtils.NS_PER_US);
  }
}
