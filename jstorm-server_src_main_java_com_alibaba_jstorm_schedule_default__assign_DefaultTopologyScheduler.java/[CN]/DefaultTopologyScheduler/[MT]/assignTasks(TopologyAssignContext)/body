{
  int assignType=context.getAssignType();
  if (TopologyAssignContext.isAssignTypeValid(assignType) == false) {
    throw new FailedAssignTopologyException("Invalide Assign Type " + assignType);
  }
  DefaultTopologyAssignContext defaultContext=new DefaultTopologyAssignContext(context);
  if (assignType == TopologyAssignContext.ASSIGN_TYPE_REBALANCE) {
    freeUsed(defaultContext);
  }
  LOG.info("Dead tasks:" + defaultContext.getDeadTaskIds());
  LOG.info("Unstopped tasks:" + defaultContext.getUnstoppedTaskIds());
  Set<Integer> needAssignTasks=getNeedAssignTasks(defaultContext);
  Set<ResourceWorkerSlot> keepAssigns=getKeepAssign(defaultContext,needAssignTasks);
  Set<ResourceWorkerSlot> ret=new HashSet<ResourceWorkerSlot>();
  ret.addAll(keepAssigns);
  ret.addAll(defaultContext.getUnstoppedWorkers());
  int allocWorkerNum=defaultContext.getTotalWorkerNum() - defaultContext.getUnstoppedWorkerNum() - keepAssigns.size();
  if (allocWorkerNum <= 0) {
    LOG.warn("Don't need assign workers, all workers are fine " + defaultContext.toDetailString());
    throw new FailedAssignTopologyException("Don't need assign worker, all workers are fine ");
  }
  List<ResourceWorkerSlot> newAssignList=WorkerMaker.getInstance().makeWorkers(defaultContext,needAssignTasks,allocWorkerNum);
  TaskGanker ganker=new TaskGanker(defaultContext,needAssignTasks,newAssignList);
  Set<ResourceWorkerSlot> newAssigns=new HashSet<ResourceWorkerSlot>(ganker.gankTask());
  ret.addAll(newAssigns);
  LOG.info("Keep Alive slots:" + keepAssigns);
  LOG.info("Unstopped slots:" + defaultContext.getUnstoppedWorkers());
  LOG.info("New assign slots:" + newAssigns);
  return ret;
}
