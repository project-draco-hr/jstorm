{
  java.util.List<Integer> out_tasks=null;
  if (out_task_id != null) {
    out_tasks=sendTargets.get(out_task_id,out_stream_id,values);
  }
 else {
    out_tasks=sendTargets.get(out_stream_id,values);
  }
  if (out_tasks.size() == 0) {
    return out_tasks;
  }
  Long root_id=MessageId.generateId();
  Boolean needAck=(message_id != null) && (ackerNum > 0);
  for (  Integer t : out_tasks) {
    MessageId msgid;
    if (needAck) {
      msgid=MessageId.makeRootId(root_id,t);
    }
 else {
      msgid=MessageId.makeUnanchored();
    }
    Tuple tp=new Tuple(topology_context,values,task_id,out_stream_id,msgid);
    transfer_fn.transfer(t,tp);
  }
  if (needAck) {
    TupleInfo info=new TupleInfo();
    info.setStream(out_stream_id);
    info.setValues(values);
    info.setMessageId(message_id);
    info.setTimestamp(System.currentTimeMillis());
    pending.put(root_id,info);
    List<Object> ackerTuple=JStormUtils.mk_list((Object)root_id,JStormUtils.bit_xor_vals(out_tasks),task_id);
    UnanchoredSend.send(topology_context,sendTargets,transfer_fn,Acker.ACKER_INIT_STREAM_ID,ackerTuple);
  }
 else   if (message_id != null) {
    ackerQueue.offer(new AckSpoutMsg(spout,message_id,isDebug,out_stream_id,0,task_stats));
  }
  return out_tasks;
}
