{
  this.task=task;
  this.storm_conf=_storm_conf;
  this.userTopologyCtx=_user_context;
  this.task_stats=_task_stats;
  this.taskId=topology_context.getThisTaskId();
  this.innerTaskTransfer=innerTaskTransfer;
  this.component_id=topology_context.getThisComponentId();
  this.idStr=JStormServerUtils.getName(component_id,taskId);
  this.taskStatus=taskStatus;
  this.report_error=_report_error;
  this.isDebug=JStormUtils.parseBoolean(storm_conf.get(Config.TOPOLOGY_DEBUG),false);
  message_timeout_secs=JStormUtils.parseInt(storm_conf.get(Config.TOPOLOGY_MESSAGE_TIMEOUT_SECS),30);
  int queue_size=Utils.getInt(storm_conf.get(Config.TOPOLOGY_EXECUTOR_RECEIVE_BUFFER_SIZE),256);
  WaitStrategy waitStrategy=(WaitStrategy)JStormUtils.createDisruptorWaitStrategy(storm_conf);
  this.exeQueue=DisruptorQueue.mkInstance(idStr,ProducerType.MULTI,queue_size,waitStrategy);
  this.exeQueue.consumerStarted();
  this.controlQueue=new LinkedBlockingDeque<Object>(8);
  this.registerInnerTransfer(exeQueue);
  QueueGauge exeQueueGauge=new QueueGauge(idStr + MetricDef.EXECUTE_QUEUE,exeQueue);
  JStormMetrics.registerTaskGauge(exeQueueGauge,taskId,MetricDef.EXECUTE_QUEUE);
  JStormHealthCheck.registerTaskHealthCheck(taskId,MetricDef.EXECUTE_QUEUE,exeQueueGauge);
  RotatingMapTrigger rotatingMapTrigger=new RotatingMapTrigger(storm_conf,idStr + "_rotating",exeQueue);
  rotatingMapTrigger.register();
  TaskHeartbeatTrigger taskHbTrigger=new TaskHeartbeatTrigger(storm_conf,idStr + "_taskHeartbeat",exeQueue,controlQueue,taskId);
  taskHbTrigger.register();
  assignmentTs=System.currentTimeMillis();
  this.taskTransfer=_transfer_fn;
}
