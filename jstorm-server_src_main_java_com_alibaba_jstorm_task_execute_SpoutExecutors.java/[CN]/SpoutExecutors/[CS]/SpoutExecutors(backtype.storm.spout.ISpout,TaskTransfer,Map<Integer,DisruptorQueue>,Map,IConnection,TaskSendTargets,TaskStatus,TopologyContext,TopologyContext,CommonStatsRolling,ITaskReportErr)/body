{
  super(_transfer_fn,_storm_conf,_puller,innerTaskTransfer,topology_context,_user_context,_task_stats,taskStatus,_report_error);
  this.spout=_spout;
  this.pending=new RotatingMap(Acker.TIMEOUT_BUCKET_NUM,new SpoutTimeoutCallBack<Object,Object>(disruptorRecvQueue,spout,storm_conf,task_stats));
  this.rotateTime=1000L * JStormUtils.parseInt(storm_conf.get(Config.TOPOLOGY_MESSAGE_TIMEOUT_SECS),30);
  this.lastRotate=System.currentTimeMillis();
  this.max_spout_pending=JStormUtils.parseInt(storm_conf.get(Config.TOPOLOGY_MAX_SPOUT_PENDING));
  if (max_spout_pending != null && max_spout_pending.intValue() == 1) {
    LOG.info("Do recv/ack in execute thread");
    supportRecvThread=false;
  }
 else {
    LOG.info("Do recv/ack in extra thread");
    supportRecvThread=true;
  }
  if (supportRecvThread == true) {
    AsyncLoopThread thread=new AsyncLoopThread(new AckerRunnable());
  }
  this.output_collector=new SpoutCollector(taskId,spout,task_stats,sendTargets,storm_conf,_transfer_fn,pending,topology_context,disruptorRecvQueue,_report_error);
  try {
    WorkerClassLoader.switchThreadContext();
    this.spout.open(storm_conf,userTopologyCtx,new SpoutOutputCollector(output_collector));
  }
 catch (  Exception e) {
    error=e;
    LOG.error("spout open error ",e);
    report_error.report(e);
  }
 finally {
    WorkerClassLoader.restoreThreadContext();
  }
  LOG.info("Successfully create SpoutExecutors " + idStr);
}
