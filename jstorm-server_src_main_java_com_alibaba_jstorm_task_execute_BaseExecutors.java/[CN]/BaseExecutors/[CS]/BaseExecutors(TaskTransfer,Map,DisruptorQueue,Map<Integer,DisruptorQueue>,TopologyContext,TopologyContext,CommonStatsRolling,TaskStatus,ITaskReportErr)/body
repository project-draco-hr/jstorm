{
  this.storm_conf=_storm_conf;
  this.deserializeQueue=deserializeQueue;
  this.userTopologyCtx=_user_context;
  this.task_stats=_task_stats;
  this.taskId=topology_context.getThisTaskId();
  this.innerTaskTransfer=innerTaskTransfer;
  this.component_id=topology_context.getThisComponentId();
  this.idStr=JStormServerUtils.getName(component_id,taskId);
  this.taskStatus=taskStatus;
  this.report_error=_report_error;
  this.deserializer=new KryoTupleDeserializer(storm_conf,topology_context);
  this.isDebugRecv=ConfigExtension.isTopologyDebugRecvTuple(storm_conf);
  this.isDebug=JStormUtils.parseBoolean(storm_conf.get(Config.TOPOLOGY_DEBUG),false);
  message_timeout_secs=JStormUtils.parseInt(storm_conf.get(Config.TOPOLOGY_MESSAGE_TIMEOUT_SECS),30);
  int queue_size=Utils.getInt(storm_conf.get(Config.TOPOLOGY_EXECUTOR_RECEIVE_BUFFER_SIZE),256);
  WaitStrategy waitStrategy=(WaitStrategy)Utils.newInstance((String)storm_conf.get(Config.TOPOLOGY_DISRUPTOR_WAIT_STRATEGY));
  this.exeQueue=DisruptorQueue.mkInstance(idStr,ProducerType.MULTI,queue_size,waitStrategy);
  this.exeQueue.consumerStarted();
  this.registerInnerTransfer(exeQueue);
  deserializeThread=new AsyncLoopThread(new DeserializeRunnable(deserializeQueue,exeQueue));
  deserializeTimer=Metrics.registerTimer(idStr,MetricDef.DESERIALIZE_TIME,String.valueOf(taskId),Metrics.MetricType.TASK);
  Metrics.registerQueue(idStr,MetricDef.DESERIALIZE_QUEUE,deserializeQueue,String.valueOf(taskId),Metrics.MetricType.TASK);
  Metrics.registerQueue(idStr,MetricDef.EXECUTE_QUEUE,exeQueue,String.valueOf(taskId),Metrics.MetricType.TASK);
  RotatingMapTrigger rotatingMapTrigger=new RotatingMapTrigger(storm_conf,idStr + "_rotating",exeQueue);
  rotatingMapTrigger.register();
}
